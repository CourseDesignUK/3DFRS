<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>3D Viewer with Annotations</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body { margin:0; overflow:hidden; font-family:system-ui; background:#f2f2f2; }
#ui {
  position:fixed; top:10px; left:10px;
  background:rgba(0,0,0,0.85);
  padding:12px; border-radius:10px;
  width:260px; color:white; z-index:10;
}
button, input { width:100%; margin-bottom:6px; }

.annotation {
  position:absolute;
  background:rgba(0,0,0,0.8);
  color:white;
  padding:4px 8px;
  border-radius:12px;
  font-size:12px;
  white-space:nowrap;
  cursor:pointer;
  pointer-events:auto;
}
</style>
</head>
<body>

<div id="ui">
  <button id="loadBtn">Load Chinook</button>
  <button id="rotateBtn">Rotate</button>
  <p style="font-size:12px;opacity:.8">
    Press <b>A</b> to add annotations
  </p>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.146.0/examples/js/loaders/GLTFLoader.js"></script>

<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0xf2f2f2);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 1000);
camera.position.set(0,1.5,3);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

scene.add(new THREE.AmbientLight(0xffffff,0.3));
const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(5,5,5);
scene.add(light);

const camLight = new THREE.PointLight(0xffffff,0.6,10);
camera.add(camLight);
scene.add(camera);

let model = null;
let autoRotate = false;
let authorMode = false;

const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();

// Annotation system
const annotations = [];
const annotationLayer = document.createElement('div');
annotationLayer.style.position = 'absolute';
annotationLayer.style.top = 0;
annotationLayer.style.left = 0;
annotationLayer.style.pointerEvents = 'none';
document.body.appendChild(annotationLayer);

// ---------- LOAD MODEL + JSON ----------
async function loadChinook() {
  const modelURL = 'https://raw.githubusercontent.com/CourseDesignUK/3DFRS/main/models/chinook.glb';
  const jsonURL = 'https://raw.githubusercontent.com/CourseDesignUK/3DFRS/main/annotations/chinook.json';

  new THREE.GLTFLoader().load(
    modelURL,
    async gltf => {
      model = gltf.scene;
      scene.add(model);
      centerAndScale(model);

      try {
        const data = await fetch(jsonURL).then(r=>r.json());
        createAnnotations(data.annotations);
      } catch(err) {
        console.error('Error loading annotations JSON:', err);
      }
    },
    xhr => console.log(`Chinook model ${(xhr.loaded/xhr.total*100).toFixed(2)}% loaded`),
    error => console.error('Error loading Chinook GLB:', error)
  );
}

function centerAndScale(obj){
  const box = new THREE.Box3().setFromObject(obj);
  const size = new THREE.Vector3();
  box.getSize(size);
  const scale = 1.5 / Math.max(size.x,size.y,size.z);
  obj.scale.setScalar(scale);
  box.setFromObject(obj);
  const c = new THREE.Vector3();
  box.getCenter(c);
  obj.position.sub(c);
}

// ---------- ANNOTATIONS ----------
function createAnnotations(data){
  data.forEach(a=>{
    const el = document.createElement('div');
    el.className = 'annotation';
    el.innerText = a.title;
    el.onclick = ()=> flyTo(a.position);
    annotationLayer.appendChild(el);

    annotations.push({
      position: new THREE.Vector3().fromArray(a.position),
      element: el
    });
  });
}

function updateAnnotations(){
  if(!model) return;

  annotations.forEach(a=>{
    const world = model.localToWorld(a.position.clone());

    // Occlusion test
    raycaster.set(camera.position, world.clone().sub(camera.position).normalize());
    const hits = raycaster.intersectObject(model,true);
    if(hits.length && hits[0].distance < camera.position.distanceTo(world)){
      a.element.style.display='none';
      return;
    }

    world.project(camera);
    const x = (world.x*0.5+0.5)*innerWidth;
    const y = (-world.y*0.5+0.5)*innerHeight;

    a.element.style.transform =
      `translate(-50%,-50%) translate(${x}px,${y}px)`;
    a.element.style.display='block';
  });
}

// ---------- AUTHOR MODE ----------
window.addEventListener('keydown',e=>{
  if(e.key.toLowerCase()==='a'){
    authorMode = !authorMode;
    alert(authorMode ? 'Author mode ON' : 'Author mode OFF');
  }
});

renderer.domElement.addEventListener('click',e=>{
  if(!authorMode || !model) return;

  mouse.x = (e.clientX/innerWidth)*2-1;
  mouse.y = -(e.clientY/innerHeight)*2+1;
  raycaster.setFromCamera(mouse,camera);
  const hits = raycaster.intersectObject(model,true);
  if(!hits.length) return;

  const local = model.worldToLocal(hits[0].point.clone());
  console.log('ANNOTATION POSITION:', local.toArray());

  alert('Position logged to console.\nCopy into chinook.json');
});

// ---------- CAMERA FLY TO ----------
function flyTo(posArr){
  const target = new THREE.Vector3().fromArray(posArr);
  const world = model.localToWorld(target.clone());
  controls.target.copy(world);

  camera.position.lerp(
    world.clone().add(new THREE.Vector3(0,1,2)),
    0.15
  );
}

// ---------- UI ----------
document.getElementById('loadBtn').onclick = loadChinook;
document.getElementById('rotateBtn').onclick = ()=>autoRotate=!autoRotate;

// ---------- LOOP ----------
function animate(){
  requestAnimationFrame(animate);
  if(autoRotate && model) model.rotation.y += 0.01;
  controls.update();
  updateAnnotations();
  renderer.render(scene,camera);
}
animate();

window.addEventListener('resize',()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
